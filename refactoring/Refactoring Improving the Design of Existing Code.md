# 重构 改善既有代码的设计

> 重构（refactoring）：在不改变软件可观察行为的前提下改善其内部结构。
即，在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构。


有人把《重构》与《设计模式》并列为Java行业的圣经。
重构已经成为一种生活方式，而《设计模式》则时常翻阅，因为总是记得不那么真切。

第一章：重构是什么？以示例的方式讲解重构的过程。  
第二章：为什么应该重构。  
第三章：该在什么地方重构。根据一些代码特征，指出需要重构的地方。
如果想着手进行重构，请完整阅读前四章，然后选择性地阅读重构列表。



## 第1章 重构，第一个案例
> 如果发现需要为程序添加一个新特性，而代码结构又无法很方便的达成目的，则，线重构那个程序，使特性的添加比较容易进行后，再添加特性。

### 重构的步骤
1. 为即将修改的代码建立一组可靠的测试环境，这些测试必须有自我检验能力。
2. 分解并重组函数。代码块越小，代码的功能就越容易管理，代码的处理和移动也就越轻松。  
（1）重构技术是以微小的步伐修改程序。如果犯下错误，很容易便可发现它。  
（2）每次修改，立刻编译并测试，确保没有破坏任何东西。  
（3）变量名称是代码清晰的关键。如果为了提高代码的清晰度，需要修改某些东西的名字，那么就大胆去做吧。只要有良好的查找/替换工具，更改名称并不困难。  
（4）去除临时变量。临时变量只在所属的函数中有效，会助长冗长而复杂的函数。
3. 运用多态取代条件逻辑

### 小结
> 重构的节奏：测试、小修改、测试、小修改······正是这种节奏让重构得以快速而安全地前进。


## 第2章 重构原则
> 重构：使用一些列重构手法，在不改变软件可观察行为的前提下，调整其结构。
1. 重构的目的是使软件更容易被理解和修改。
2. 重构不会改变软件可观察的行为，即重构之后软件功能不变。

添加新功能：不修改既有代码，只管添加新功能，通过测试衡量工作进度。  
重构：不能添加新功能，只管改进程序结构。

### 2.1 为何重构
1. 重构改进软件设计  
消除重复代码，不会使系统更快，而在于方便未来的修改。代码越多，修改代码越困难。
2. 重构是软件更容易理解  
（1）在重构上花一点点时间，就可以让代码更好的表达自己的用途。  
（2）利用重构来协助理解不熟悉的代码。
3. 重构帮助找到bug
4. 重构提高编程速度  
重构，改善设计、提高可读性、减少错误，这些都是提高质量。  
良好的设计是维持软件开发速度的根本。重构可以帮助更快地开发软件，因为它阻止系统腐败变质，甚至可以提高设计质量。

### 2.2 何时重构
> 重构应该随时随地进行。不应该为重构而重构，之所以重构，是因为想做别的事情，而重构可以帮助把那些事做好。

1. 添加功能时重构
重构的直接原因是为了帮助理解需要修改的代码（这些代码可能是别人写的，也可能是自己写的）。是否能对这段代码进行重构，使我能更快地理解它，然后我就会重构。  
代码的设计无法轻松添加新特性时，需要重构，以添加新特性。
2. 修补错误时重构
调试过程中运用重构，多半是为了让代码更具可读性，使代码清晰到一眼看出bug。
3. 复审代码时重构  
代码复审：  
（1）可以改善开发状况；  
（2）有助于让较有经验的开发者把知识传递给比较欠缺经验的人；  
（3）帮助更多人理解大型软件系统中的更多部分；  
（4）代码复审对编写清晰代码很重要。  
重构，可以帮助复审别人的代码。

### 2.3 重构的难题
1. 数据库
2. 修改接口
3. 何时不该重构而该重写

## 第3章 代码的坏味道
### 3.1 Duplicated Code （重复代码）
1. “同一个类的两个函数含有相同的表达式”，采用Extract Method(110) 提炼出重复的代码，然后让两个地点都调用。
2. “两个互为兄弟的子类内含相同表达式”，对两个类都采用Extract Method(110) 提炼出重复的代码，然后对被提炼出的代码使用 Pull Up Method（332），将它推入超类内。

### 3.2 Long Method （过长函数）
1. 大量参数和临时变量，会对函数提炼形成阻碍。  
（1）采用 Replace Temp with Query(120) 来消除临时变量。  
（2）Introduce Parameter Object(295) 和 Preserve Whole Object(288) 将过长的参数列变简洁。  
（3）杀手锏：Replace Method with Method Object(135)。  
2. 提炼的信号  
（1）寻找注释。如果代码前有一段注释，提醒可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。就算只有一行代码，如果它需要注释来说明，那也值得将它提炼到独立函数中。  
（2）条件表达式和循环 常常也是提炼的信号。条件表达式可以运用 Decompose Conditional(238)处理；可以将循环和其内的代码提炼到一个独立函数中。

### 3.3 Large Class （过大的类）
如果单个类做太多事情，其内往往会出现太多实例变量，Duplicated Code 也就接踵而至。  
（1）运用 Extract Class(149) 将几个变量一起提炼至新类内；  
（2）如果这个组件适合作为一个子类，Extract Subclass(330) 往往比较简单。
一个类如果拥有太多代码， 往往适合使用 Extract Class 和 Extract Subclass。

### 3.4 Long Parameter List （过长参数列）
面向对象技术，如果手上没有所需要的东西，总可以叫另一个对象给你。  
面向对象程序中的函数，其参数列表通常比传统程序中短很多。  
（1）如果向已有的对象发出一条请求就可以取代一个参数，那么应该激活重构手法 Replace Parameter with Method(292)；  
（2）可以运用 Preserve Whole Object(288) 将来自同一对象的一堆数据收集起来，并以该对象替换它们；  
（3）如果某些数据缺乏合理的对象归属，可使用 Introduce Parameter Object(295) 为它们制造一个“参数对象”。

### 3.5 Divergent Change （发散式变化）

### 3.21 Refused Bequest （被拒绝的遗赠）

### 3.22 Comments （过多的注释）
注释是为了补充说明代码。但常常会有这样的情况：一段代码有着长长的注释，这些注释之所以存在乃是因为代码很糟糕。  
Comments 可以帮忙找到前面提到的各种坏味道，经过重构之后，注释已经变得多余了，因为代码已经说明了一切。  
（1）如果需要注释来解释一块代码块做了什么，试试 Extract Method(110)；  
（2）如果函数已经提炼出来，但还需要注释来解释其行为，试试 Rename Method(273)；  
（3）如果需要注释说明某些系统的需求规格，试试 Introduce Assertion(267)。
> 当感觉需要撰写注释时，先试着重构，试着让所有注释变得多余。

## 第4章 构筑测试体系

## 第6章 重新组织函数
### 6.1 Extract Method(提炼函数)
> 将一段代码放进一个独立函数中，并让函数名称解释该函数的用途。

简短而命名良好的函数：  
（1）如果每个函数的粒度都很小，那么函数被复用的机会就更大；  
（2）使高层函数读起来就像一系列注释；  
（3）如果函数都是细粒度，那么函数的覆写也会更容易些。

长度不是问题，关键在于函数名称和函数体之间的语义距离。

做法：
（1）创建新函数，根据函数意图来命名；  
（2）将提炼出的代码从源函数复制到新函数中；  
（3）检查代码，，找出“作用域限于源函数”的变量，包括局部变量和参数；  
（4）检查是否有“仅用于被提炼代码段”的临时变量。如果有，在目标函数中将它们声明为临时变量；  
（5）使用Replace Temp with Query(120) 将临时变量消灭掉；  
（6）将被提炼代码段中需要读取的局部变量，当作参数传递给目标函数；  
（7）处理完所有局部变量之后，进行编译；  
（8）在源函数中，将被提炼代码段替换为目标函数的调用；  
（9）编译，测试。

> 如果局部变量为数众多，先运用Replace Temp with Query(120)减少临时变量，再考虑使用Replace Method with Method Object(135)。

### 6.2 Inline Method(内联函数)
> 一个函数的本体与名称同样清楚易懂，在函数调用点插入函数本体，然后移除该函数。

### 6.3 Inline Temp(内联临时变量)
> 一个临时变量，只被一个简单表达式赋值一次，而它妨碍了其他重构手法，将该变量的引用动作，替换为它赋值的那个表达式自身。

Inline Temp(119)大多是作为Replace Temp with Query(120)的一部分使用。

### 6.4 Replace Temp with Query(以查询取代临时变量)
> 一个临时变量保存某一表达式的运算结果，可将这个表达式提炼到一个独立函数中，将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。

### 6.5 Introduce Explaining Variable(引入解释性变量)
> 将一个复杂表达式(或其中一部分)的结果放进一个临时变量，以此变量名称来解释表达式用途。  
动机：表达式可能非常复杂而难以阅读，临时变量可以将表达式分解为比较容易管理的形式。

### 6.6 Split Temporary Variable(分解临时变量)
> 程序中某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。针对每次赋值，创造一个独立、对应的临时变量。

### 6.7 Remove Assignments to Parameters(移除对参数的赋值)
> 代码对一个参数进行赋值时，以一个临时变量取代该参数的位置。

### 6.8 Replace Method with Method Object(以函数对象取代函数)
> 将函数放进一个单独对象中，局部变量就成了函数对象内的字段，然后可以在同一个对象中将这个大型函数分解为多个小型函数。

做法：  
（1）建立一个新类，根据待处理函数的用途，为类命名；  
（2）在新类中建立一个final字段，用以保存原先大型函数所在的对象，即源对象；  
针对原函数的每个临时变量和每个参数，在新类中建立对应的字段保存之；  
（3）构造函数，接收源对象和原函数的所有参数；  
（4）在新类中建立一个compute()函数，将原函数的代码复制到compute()中。如果需要调用源对象的任何函数，可通过源对象字段调用；  
（5）编译；  
（6）将旧函数的函数本体替换为：创建新类的一个对象，而后调用其中的compute()函数。

### 6.9 Substitute Algorithm(替换算法)
> 当需要把某个算法替换为另一个更清晰的算法时，将函数体替换为另一个算法。


## 第8章 重新组织数据
